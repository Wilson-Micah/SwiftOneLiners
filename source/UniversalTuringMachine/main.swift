func universalTuringMachine(tape: [Int]) -> [Int] {
    if true, case let table = [[(1, 1, 0), (0, 1, 1), (3, -1, 3), (1, -1, 3), (0, 0, 0)], [(0, -1, 0), (0, 1, 1), (0, 1, 2), (0, 1, 1), (1, 1, 4)], [(4, 1, 0), (0, -1, 3), (2, 1, 4), (4, -1, 2), (0, 0, 0)], [(0, 1, 1), (3, 1, 1), (3, 1, 2), (3, -1, 3), (1, 1, 0)], [(2, -1, 0), (4, 1, 1), (4, 1, 2), (4, -1, 3), (2, 1, 4)]], case let move = { (_ machine: (state: Int, head: Int, left: [Int], right: [Int])) -> (Int, Int, [Int], [Int])? in if true, case let (write, move, state) = table[machine.head][machine.state] {return move == -1 ? (state, machine.left.last ?? 2, machine.left.dropLast(), machine.right + [write]) : move == 1 ? (state, machine.right.last ?? 2, machine.left + [write], machine.right.dropLast()) : nil}}, case let U = { (f: Any) in (f as! (Any) -> Any)(f) }, case let machine = (U { (f: Any) -> Any in { (machine: (Int, Int, [Int], [Int])) -> (Int, Int, [Int], [Int]) in move(machine).map { (U(f) as! ((Int, Int, [Int], [Int])) -> (Int, Int, [Int], [Int]))($0) } ?? machine}} as! (((Int, Int, [Int], [Int])) -> (Int, Int, [Int], [Int])))((0, tape.first ?? 2, Array(tape.dropFirst()), [])) {return machine.2 + [machine.1] + machine.3.reversed()}
}
